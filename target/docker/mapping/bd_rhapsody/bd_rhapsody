#!/usr/bin/env bash

# bd_rhapsody 1.0.5
# 
# This wrapper script is auto-generated by viash 0.8.8 and is thus a derivative
# work thereof. This software comes with ABSOLUTELY NO WARRANTY from Data
# Intuitive.
# 
# The component may contain files which fall under a different license. The
# authors of this component should specify the license in the header of such
# files, or include a separate license file detailing the licenses of all included
# files.
# 
# Component authors:
#  * Robrecht Cannoodt (maintainer)

set -e

if [ -z "$VIASH_TEMP" ]; then
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TEMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMP}
  VIASH_TEMP=${VIASH_TEMP:-$TMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$TMP}
  VIASH_TEMP=${VIASH_TEMP:-$TEMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$TEMP}
  VIASH_TEMP=${VIASH_TEMP:-/tmp}
fi

# define helper functions
# ViashQuote: put quotes around non flag values
# $1     : unquoted string
# return : possibly quoted string
# examples:
#   ViashQuote --foo      # returns --foo
#   ViashQuote bar        # returns 'bar'
#   Viashquote --foo=bar  # returns --foo='bar'
function ViashQuote {
  if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
    echo "$1" | sed "s#=\(.*\)#='\1'#"
  elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
    echo "$1"
  else
    echo "'$1'"
  fi
}
# ViashRemoveFlags: Remove leading flag
# $1     : string with a possible leading flag
# return : string without possible leading flag
# examples:
#   ViashRemoveFlags --foo=bar  # returns bar
function ViashRemoveFlags {
  echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
}
# ViashSourceDir: return the path of a bash file, following symlinks
# usage   : ViashSourceDir ${BASH_SOURCE[0]}
# $1      : Should always be set to ${BASH_SOURCE[0]}
# returns : The absolute path of the bash file
function ViashSourceDir {
  SOURCE="$1"
  while [ -h "$SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
}
# ViashFindTargetDir: return the path of the '.build.yaml' file, following symlinks
# usage   : ViashFindTargetDir 'ScriptPath'
# $1      : The location from where to start the upward search
# returns : The absolute path of the '.build.yaml' file
function ViashFindTargetDir {
  SOURCE="$1"
  while [[ "$SOURCE" != "" && ! -e "$SOURCE/.build.yaml" ]]; do
    SOURCE=${SOURCE%/*}
  done
  echo $SOURCE
}
# see https://en.wikipedia.org/wiki/Syslog#Severity_level
VIASH_LOGCODE_EMERGENCY=0
VIASH_LOGCODE_ALERT=1
VIASH_LOGCODE_CRITICAL=2
VIASH_LOGCODE_ERROR=3
VIASH_LOGCODE_WARNING=4
VIASH_LOGCODE_NOTICE=5
VIASH_LOGCODE_INFO=6
VIASH_LOGCODE_DEBUG=7
VIASH_VERBOSITY=$VIASH_LOGCODE_NOTICE

# ViashLog: Log events depending on the verbosity level
# usage: ViashLog 1 alert Oh no something went wrong!
# $1: required verbosity level
# $2: display tag
# $3+: messages to display
# stdout: Your input, prepended by '[$2] '.
function ViashLog {
  local required_level="$1"
  local display_tag="$2"
  shift 2
  if [ $VIASH_VERBOSITY -ge $required_level ]; then
    >&2 echo "[$display_tag]" "$@"
  fi
}

# ViashEmergency: log events when the system is unstable
# usage: ViashEmergency Oh no something went wrong.
# stdout: Your input, prepended by '[emergency] '.
function ViashEmergency {
  ViashLog $VIASH_LOGCODE_EMERGENCY emergency "$@"
}

# ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
# usage: ViashAlert Oh no something went wrong.
# stdout: Your input, prepended by '[alert] '.
function ViashAlert {
  ViashLog $VIASH_LOGCODE_ALERT alert "$@"
}

# ViashCritical: log events when a critical condition occurs
# usage: ViashCritical Oh no something went wrong.
# stdout: Your input, prepended by '[critical] '.
function ViashCritical {
  ViashLog $VIASH_LOGCODE_CRITICAL critical "$@"
}

# ViashError: log events when an error condition occurs
# usage: ViashError Oh no something went wrong.
# stdout: Your input, prepended by '[error] '.
function ViashError {
  ViashLog $VIASH_LOGCODE_ERROR error "$@"
}

# ViashWarning: log potentially abnormal events
# usage: ViashWarning Something may have gone wrong.
# stdout: Your input, prepended by '[warning] '.
function ViashWarning {
  ViashLog $VIASH_LOGCODE_WARNING warning "$@"
}

# ViashNotice: log significant but normal events
# usage: ViashNotice This just happened.
# stdout: Your input, prepended by '[notice] '.
function ViashNotice {
  ViashLog $VIASH_LOGCODE_NOTICE notice "$@"
}

# ViashInfo: log normal events
# usage: ViashInfo This just happened.
# stdout: Your input, prepended by '[info] '.
function ViashInfo {
  ViashLog $VIASH_LOGCODE_INFO info "$@"
}

# ViashDebug: log all events, for debugging purposes
# usage: ViashDebug This just happened.
# stdout: Your input, prepended by '[debug] '.
function ViashDebug {
  ViashLog $VIASH_LOGCODE_DEBUG debug "$@"
}

# find source folder of this component
VIASH_META_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`

# find the root of the built components & dependencies
VIASH_TARGET_DIR=`ViashFindTargetDir $VIASH_META_RESOURCES_DIR`

# define meta fields
VIASH_META_FUNCTIONALITY_NAME="bd_rhapsody"
VIASH_META_EXECUTABLE="$VIASH_META_RESOURCES_DIR/$VIASH_META_FUNCTIONALITY_NAME"
VIASH_META_CONFIG="$VIASH_META_RESOURCES_DIR/.config.vsh.yaml"
VIASH_META_TEMP_DIR="$VIASH_TEMP"


# ViashHelp: Display helpful explanation about this executable
function ViashHelp {
  echo "bd_rhapsody 1.0.5"
  echo ""
  echo "A wrapper for the BD Rhapsody Analysis CWL v1.10.1 pipeline."
  echo ""
  echo "The CWL pipeline file is obtained by cloning"
  echo "'https://bitbucket.org/CRSwDev/cwl/src/master/' and removing all objects with"
  echo "class 'DockerRequirement' from the YML."
  echo ""
  echo "This pipeline can be used for a targeted analysis (with \`--mode targeted\`) or"
  echo "for a whole transcriptome analysis (with \`--mode wta\`)."
  echo ""
  echo "* If mode is \`\"targeted\"\`, then either the \`--reference\` or \`--abseq_reference\`"
  echo "parameters must be defined."
  echo "* If mode is \`\"wta\"\`, then \`--reference\` and \`--transcriptome_annotation\` must"
  echo "be defined, \`--abseq_reference\` and \`--supplemental_reference\` is optional."
  echo ""
  echo "The reference_genome and transcriptome_annotation files can be generated with"
  echo "the make_reference pipeline."
  echo "Alternatively, BD also provides standard references which can be downloaded from"
  echo "these locations:"
  echo ""
  echo "  - Human:"
  echo "http://bd-rhapsody-public.s3-website-us-east-1.amazonaws.com/Rhapsody-WTA/GRCh38-PhiX-gencodev29/"
  echo "  - Mouse:"
  echo "http://bd-rhapsody-public.s3-website-us-east-1.amazonaws.com/Rhapsody-WTA/GRCm38-PhiX-gencodevM19/"
  echo ""
  echo "Inputs:"
  echo "    --mode"
  echo "        type: string, required parameter"
  echo "        example: wta"
  echo "        choices: [ wta, targeted ]"
  echo "        Whether to run a whole transcriptome analysis (WTA) or a targeted"
  echo "        analysis."
  echo ""
  echo "    -i, --input"
  echo "        type: file, required parameter, multiple values allowed, file must exist"
  echo "        example: input.fastq.gz"
  echo "        Path to your read files in the FASTQ.GZ format. You may specify as many"
  echo "        R1/R2 read pairs as you want."
  echo ""
  echo "    -r, --reference_genome, --reference"
  echo "        type: file, required parameter, multiple values allowed, file must exist"
  echo "        example: reference_genome.tar.gz|reference.fasta"
  echo "        Refence to map to. For \`--mode wta\`, this is the path to STAR index as a"
  echo "        tar.gz file. For \`--mode targeted\`, this is the path to mRNA reference"
  echo "        file for pre-designed, supplemental, or custom panel, in FASTA format"
  echo ""
  echo "    -t, --transcriptome_annotation"
  echo "        type: file, file must exist"
  echo "        example: transcriptome.gtf"
  echo "        Path to GTF annotation file (only for \`--mode wta\`)."
  echo ""
  echo "    -a, --abseq_reference"
  echo "        type: file, multiple values allowed, file must exist"
  echo "        example: abseq_reference.fasta"
  echo "        Path to the AbSeq reference file in FASTA format. Only needed if BD"
  echo "        AbSeq Ab-Oligos are used."
  echo ""
  echo "    -s, --supplemental_reference"
  echo "        type: file, multiple values allowed, file must exist"
  echo "        example: supplemental_reference.fasta"
  echo "        Path to the supplemental reference file in FASTA format. Only needed if"
  echo "        there are additional transgene sequences used in the experiment (only"
  echo "        for \`--mode wta\`)."
  echo ""
  echo "    --sample_prefix"
  echo "        type: string"
  echo "        default: sample"
  echo "        Specify a run name to use as the output file base name. Use only"
  echo "        letters, numbers, or hyphens. Do not use special characters or spaces."
  echo ""
  echo "Outputs:"
  echo "    -o, --output"
  echo "        type: file, required parameter, output, file must exist"
  echo "        example: output_dir"
  echo "        Output folder. Output still needs to be processed further."
  echo ""
  echo "Putative cell calling settings:"
  echo "    --putative_cell_call"
  echo "        type: string"
  echo "        example: mRNA"
  echo "        choices: [ mRNA, AbSeq_Experimental ]"
  echo "        Specify the dataset to be used for putative cell calling. For putative"
  echo "        cell calling using an AbSeq dataset, please provide an AbSeq_Reference"
  echo "        fasta file above."
  echo ""
  echo "    --exact_cell_count"
  echo "        type: integer"
  echo "        example: 10000"
  echo "        Exact cell count - Set a specific number (>=1) of cells as putative,"
  echo "        based on those with the highest error-corrected read count"
  echo ""
  echo "    --disable_putative_calling"
  echo "        type: boolean_true"
  echo "        Disable Refined Putative Cell Calling - Determine putative cells using"
  echo "        only the basic algorithm (minimum second derivative along the cumulative"
  echo "        reads curve). The refined algorithm attempts to remove false positives"
  echo "        and recover false negatives, but may not be ideal for certain complex"
  echo "        mixtures of cell types. Does not apply if Exact Cell Count is set."
  echo ""
  echo "Subsample arguments:"
  echo "    --subsample"
  echo "        type: double"
  echo "        example: 0.01"
  echo "        A number >1 or fraction (0 < n < 1) to indicate the number or percentage"
  echo "        of reads to subsample."
  echo ""
  echo "    --subsample_seed"
  echo "        type: integer"
  echo "        example: 3445"
  echo "        A seed for replicating a previous subsampled run."
  echo ""
  echo "Multiplex arguments:"
  echo "    --sample_tags_version"
  echo "        type: string"
  echo "        example: human"
  echo "        choices: [ human, hs, mouse, mm ]"
  echo "        Specify if multiplexed run."
  echo ""
  echo "    --tag_names"
  echo "        type: string, multiple values allowed"
  echo "        example: 4-mySample;9-myOtherSample;6-alsoThisSample"
  echo "        Tag_Names (optional) - Specify the tag number followed by '-' and the"
  echo "        desired sample name to appear in Sample_Tag_Metrics.csv."
  echo "        Do not use the special characters: &, (), [], {},  <>, ?, |"
  echo ""
  echo "VDJ arguments:"
  echo "    --vdj_version"
  echo "        type: string"
  echo "        example: human"
  echo "        choices: [ human, mouse, humanBCR, humanBCR, humanTCR, mouseBCR ]"
  echo "        Specify if VDJ run."
  echo ""
  echo "CWL-runner arguments:"
  echo "    --parallel"
  echo "        type: boolean"
  echo "        default: true"
  echo "        Run jobs in parallel."
  echo ""
  echo "    --timestamps"
  echo "        type: boolean_true"
  echo "        Add timestamps to the errors, warnings, and notifications."
  echo ""
  echo "    --dryrun"
  echo "        type: boolean_true"
  echo "        If true, the output directory will only contain the CWL input files, but"
  echo "        the pipeline itself will not be executed."
}

######## Helper functions for setting up Docker images for viash ########
# expects: ViashDockerBuild

# ViashDockerInstallationCheck: check whether Docker is installed correctly
#
# examples:
#   ViashDockerInstallationCheck
function ViashDockerInstallationCheck {
  ViashDebug "Checking whether Docker is installed"
  if [ ! command -v docker &> /dev/null ]; then
    ViashCritical "Docker doesn't seem to be installed. See 'https://docs.docker.com/get-docker/' for instructions."
    exit 1
  fi

  ViashDebug "Checking whether the Docker daemon is running"
  save=$-; set +e
  docker_version=$(docker version --format '{{.Client.APIVersion}}' 2> /dev/null)
  out=$?
  [[ $save =~ e ]] && set -e
  if [ $out -ne 0 ]; then
    ViashCritical "Docker daemon does not seem to be running. Try one of the following:"
    ViashCritical "- Try running 'dockerd' in the command line"
    ViashCritical "- See https://docs.docker.com/config/daemon/"
    exit 1
  fi
}

# ViashDockerRemoteTagCheck: check whether a Docker image is available 
# on a remote. Assumes `docker login` has been performed, if relevant.
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerRemoteTagCheck python:latest
#   echo $?                                     # returns '0'
#   ViashDockerRemoteTagCheck sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerRemoteTagCheck {
  docker manifest inspect $1 > /dev/null 2> /dev/null
}

# ViashDockerLocalTagCheck: check whether a Docker image is available locally
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   docker pull python:latest
#   ViashDockerLocalTagCheck python:latest
#   echo $?                                     # returns '0'
#   ViashDockerLocalTagCheck sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerLocalTagCheck {
  [ -n "$(docker images -q $1)" ]
}

# ViashDockerPull: pull a Docker image
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerPull python:latest
#   echo $?                                     # returns '0'
#   ViashDockerPull sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerPull {
  ViashNotice "Checking if Docker image is available at '$1'"
  if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
    docker pull $1 && return 0 || return 1
  else
    save=$-; set +e
    docker pull $1 2> /dev/null > /dev/null
    out=$?
    [[ $save =~ e ]] && set -e
    if [ $out -ne 0 ]; then
      ViashWarning "Could not pull from '$1'. Docker image doesn't exist or is not accessible."
    fi
    return $out
  fi
}

# ViashDockerPush: push a Docker image
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerPush python:latest
#   echo $?                                     # returns '0'
#   ViashDockerPush sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerPush {
  ViashNotice "Pushing image to '$1'"
  save=$-; set +e
  if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
    docker push $1
    out=$?
  else
    docker push $1 2> /dev/null > /dev/null
    out=$?
  fi
  [[ $save =~ e ]] && set -e
  if [ $out -eq 0 ]; then
    ViashNotice "Container '$VSHD_ID' push succeeded."
  else
    ViashError "Container '$VSHD_ID' push errored. You might not be logged in or have the necessary permissions."
  fi
  return $out
}

# ViashDockerPullElseBuild: pull a Docker image, else build it
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
# examples:
#   ViashDockerPullElseBuild mynewcomponent
function ViashDockerPullElseBuild {
  save=$-; set +e
  ViashDockerPull $1
  out=$?
  [[ $save =~ e ]] && set -e
  if [ $out -ne 0 ]; then
    ViashDockerBuild $@
  fi
}

# ViashDockerSetup: create a Docker image, according to specified docker setup strategy
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# $2                  : docker setup strategy, see DockerSetupStrategy.scala
# ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
# examples:
#   ViashDockerSetup mynewcomponent alwaysbuild
function ViashDockerSetup {
  VSHD_ID="$1"
  VSHD_STRAT="$2"
  if [ "$VSHD_STRAT" == "alwaysbuild" -o "$VSHD_STRAT" == "build" -o "$VSHD_STRAT" == "b" ]; then
    ViashDockerBuild $VSHD_ID --no-cache
  elif [ "$VSHD_STRAT" == "alwayspull" -o "$VSHD_STRAT" == "pull" -o "$VSHD_STRAT" == "p" ]; then
    ViashDockerPull $VSHD_ID
  elif [ "$VSHD_STRAT" == "alwayspullelsebuild" -o "$VSHD_STRAT" == "pullelsebuild" ]; then
    ViashDockerPullElseBuild $VSHD_ID --no-cache
  elif [ "$VSHD_STRAT" == "alwayspullelsecachedbuild" -o "$VSHD_STRAT" == "pullelsecachedbuild" ]; then
    ViashDockerPullElseBuild $VSHD_ID
  elif [ "$VSHD_STRAT" == "alwayscachedbuild" -o "$VSHD_STRAT" == "cachedbuild" -o "$VSHD_STRAT" == "cb" ]; then
    ViashDockerBuild $VSHD_ID
  elif [[ "$VSHD_STRAT" =~ ^ifneedbe ]]; then
    save=$-; set +e
    ViashDockerLocalTagCheck $VSHD_ID
    outCheck=$?
    [[ $save =~ e ]] && set -e
    if [ $outCheck -eq 0 ]; then
      ViashInfo "Image $VSHD_ID already exists"
    elif [ "$VSHD_STRAT" == "ifneedbebuild" ]; then
      ViashDockerBuild $VSHD_ID --no-cache
    elif [ "$VSHD_STRAT" == "ifneedbecachedbuild" ]; then
      ViashDockerBuild $VSHD_ID
    elif [ "$VSHD_STRAT" == "ifneedbepull" ]; then
      ViashDockerPull $VSHD_ID
    elif [ "$VSHD_STRAT" == "ifneedbepullelsebuild" ]; then
      ViashDockerPullElseBuild $VSHD_ID --no-cache
    elif [ "$VSHD_STRAT" == "ifneedbepullelsecachedbuild" ]; then
      ViashDockerPullElseBuild $VSHD_ID
    else
      ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
      exit 1
    fi
  elif [ "$VSHD_STRAT" == "push" -o "$VSHD_STRAT" == "forcepush" -o "$VSHD_STRAT" == "alwayspush" ]; then
    ViashDockerPush "$VSHD_ID"
  elif [ "$VSHD_STRAT" == "pushifnotpresent" -o "$VSHD_STRAT" == "gentlepush" -o "$VSHD_STRAT" == "maybepush" ]; then
    save=$-; set +e
    ViashDockerRemoteTagCheck $VSHD_ID
    outCheck=$?
    [[ $save =~ e ]] && set -e
    if [ $outCheck -eq 0 ]; then
      ViashNotice "Container '$VSHD_ID' exists, doing nothing."
    else
      ViashNotice "Container '$VSHD_ID' does not yet exist."
      ViashDockerPush "$VSHD_ID"
    fi
  elif [ "$VSHD_STRAT" == "donothing" -o "$VSHD_STRAT" == "meh" ]; then
    ViashNotice "Skipping setup."
  else
    ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
    exit 1
  fi
}

# ViashDockerCheckCommands: Check whether a docker container has the required commands
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# $@                  : commands to verify being present
# examples:
#   ViashDockerCheckCommands bash:4.0 bash ps foo
function ViashDockerCheckCommands {
  tag=$1
  shift 1
  commands="$@"
  save=$-; set +e
  missing=$(docker run --rm --entrypoint=sh $tag -c "for command in $commands; do command -v \$command >/dev/null 2>&1; if [ \$? -ne 0 ]; then echo \$command; exit 1; fi; done")
  outCheck=$?
  [[ $save =~ e ]] && set -e
  if [ $outCheck -ne 0 ]; then
  	ViashError "Docker container '$tag' does not contain command '$missing'."
  	exit 1
  fi
}


######## End of helper functions for setting up Docker images for viash ########

# ViashDockerFile: print the dockerfile to stdout
# return : dockerfile required to run this component
# examples:
#   ViashDockerFile
function ViashDockerfile {
  cat << 'VIASHDOCKER'
FROM ghcr.io/data-intuitive/bd_rhapsody:1.10.1

ENTRYPOINT []

 
RUN pip install --upgrade pip && \
  pip install --upgrade --no-cache-dir "pandas<2"

LABEL org.opencontainers.image.authors="Robrecht Cannoodt"
LABEL org.opencontainers.image.description="Companion container for running component mapping bd_rhapsody"
LABEL org.opencontainers.image.created="2025-04-24T13:19:36Z"
LABEL org.opencontainers.image.source="https://github.com/openpipelines-bio/openpipeline"
LABEL org.opencontainers.image.revision="bfe311bb5542f97dfe80b20a3e47a02800708f43"
LABEL org.opencontainers.image.version="1.0.5"

VIASHDOCKER
}

# ViashDockerBuild: build a docker container
# $1              : image identifier with format `[registry/]image[:tag]`
# exit code $?    : whether or not the image was built
function ViashDockerBuild {
  # create temporary directory to store dockerfile & optional resources in
  tmpdir=$(mktemp -d "$VIASH_META_TEMP_DIR/dockerbuild-bd_rhapsody-XXXXXX")
  dockerfile="$tmpdir/Dockerfile"
  function clean_up {
    rm -rf "$tmpdir"
  }
  trap clean_up EXIT

  # store dockerfile and resources
  ViashDockerfile > $dockerfile

  # Build the container
  ViashNotice "Building container '$1' with Dockerfile"
  ViashInfo "Running 'docker build -t $@ $VIASH_META_RESOURCES_DIR -f $dockerfile'"
  save=$-; set +e
  if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
    docker build -t $@ $VIASH_META_RESOURCES_DIR -f $dockerfile
  else
    docker build -t $@ $VIASH_META_RESOURCES_DIR -f $dockerfile &> $tmpdir/docker_build.log
  fi
  out=$?
  [[ $save =~ e ]] && set -e
  if [ $out -ne 0 ]; then
    ViashError "Error occurred while building container '$1'"
    if [ $VIASH_VERBOSITY -lt $VIASH_LOGCODE_INFO ]; then
      ViashError "Transcript: --------------------------------"
      cat "$tmpdir/docker_build.log"
      ViashError "End of transcript --------------------------"
    fi
    exit 1
  fi
  ViashDockerCheckCommands "$1" 'ps' 'bash'
}

# ViashAbsolutePath: generate absolute path from relative path
# borrowed from https://stackoverflow.com/a/21951256
# $1     : relative filename
# return : absolute path
# examples:
#   ViashAbsolutePath some_file.txt   # returns /path/to/some_file.txt
#   ViashAbsolutePath /foo/bar/..     # returns /foo
function ViashAbsolutePath {
  local thePath
  if [[ ! "$1" =~ ^/ ]]; then
    thePath="$PWD/$1"
  else
    thePath="$1"
  fi
  echo "$thePath" | (
    IFS=/
    read -a parr
    declare -a outp
    for i in "${parr[@]}"; do
      case "$i" in
      ''|.) continue ;;
      ..)
        len=${#outp[@]}
        if ((len==0)); then
          continue
        else
          unset outp[$((len-1))]
        fi
        ;;
      *)
        len=${#outp[@]}
        outp[$len]="$i"
      ;;
      esac
    done
    echo /"${outp[*]}"
  )
}
# ViashAutodetectMount: auto configuring docker mounts from parameters
# $1                  : The parameter value
# returns             : New parameter
# $VIASH_EXTRA_MOUNTS : Added another parameter to be passed to docker
# examples:
#   ViashAutodetectMount /path/to/bar      # returns '/viash_automount/path/to/bar'
#   ViashAutodetectMountArg /path/to/bar   # returns '--volume="/path/to:/viash_automount/path/to"'
function ViashAutodetectMount {
  abs_path=$(ViashAbsolutePath "$1")
  if [ -d "$abs_path" ]; then
    mount_source="$abs_path"
    base_name=""
  else
    mount_source=`dirname "$abs_path"`
    base_name=`basename "$abs_path"`
  fi
  mount_target="/viash_automount$mount_source"
  if [ -z "$base_name" ]; then
    echo "$mount_target"
  else
    echo "$mount_target/$base_name"
  fi
}
function ViashAutodetectMountArg {
  abs_path=$(ViashAbsolutePath "$1")
  if [ -d "$abs_path" ]; then
    mount_source="$abs_path"
    base_name=""
  else
    mount_source=`dirname "$abs_path"`
    base_name=`basename "$abs_path"`
  fi
  mount_target="/viash_automount$mount_source"
  ViashDebug "ViashAutodetectMountArg $1 -> $mount_source -> $mount_target"
  echo "--volume=\"$mount_source:$mount_target\""
}
function ViashStripAutomount {
  abs_path=$(ViashAbsolutePath "$1")
  echo "${abs_path#/viash_automount}"
}
# ViashExtractFlags: Retain leading flag
# $1     : string with a possible leading flag
# return : leading flag
# examples:
#   ViashExtractFlags --foo=bar  # returns --foo
function ViashExtractFlags {
  echo $1 | sed 's/=.*//'
}
# initialise variables
VIASH_EXTRA_MOUNTS=()

# initialise array
VIASH_POSITIONAL_ARGS=''
VIASH_MODE='run'

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            ViashHelp
            exit
            ;;
        ---v|---verbose)
            let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
            shift 1
            ;;
        ---verbosity)
            VIASH_VERBOSITY="$2"
            shift 2
            ;;
        ---verbosity=*)
            VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
            shift 1
            ;;
        --version)
            echo "bd_rhapsody 1.0.5"
            exit
            ;;
        --mode)
            [ -n "$VIASH_PAR_MODE" ] && ViashError Bad arguments for option \'--mode\': \'$VIASH_PAR_MODE\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_MODE="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --mode. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --mode=*)
            [ -n "$VIASH_PAR_MODE" ] && ViashError Bad arguments for option \'--mode=*\': \'$VIASH_PAR_MODE\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_MODE=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --input)
            if [ -z "$VIASH_PAR_INPUT" ]; then
              VIASH_PAR_INPUT="$2"
            else
              VIASH_PAR_INPUT="$VIASH_PAR_INPUT;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --input. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --input=*)
            if [ -z "$VIASH_PAR_INPUT" ]; then
              VIASH_PAR_INPUT=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_INPUT="$VIASH_PAR_INPUT;"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        -i)
            if [ -z "$VIASH_PAR_INPUT" ]; then
              VIASH_PAR_INPUT="$2"
            else
              VIASH_PAR_INPUT="$VIASH_PAR_INPUT;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -i. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --reference)
            if [ -z "$VIASH_PAR_REFERENCE" ]; then
              VIASH_PAR_REFERENCE="$2"
            else
              VIASH_PAR_REFERENCE="$VIASH_PAR_REFERENCE;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --reference. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --reference=*)
            if [ -z "$VIASH_PAR_REFERENCE" ]; then
              VIASH_PAR_REFERENCE=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_REFERENCE="$VIASH_PAR_REFERENCE;"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        -r)
            if [ -z "$VIASH_PAR_REFERENCE" ]; then
              VIASH_PAR_REFERENCE="$2"
            else
              VIASH_PAR_REFERENCE="$VIASH_PAR_REFERENCE;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -r. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --reference_genome)
            if [ -z "$VIASH_PAR_REFERENCE" ]; then
              VIASH_PAR_REFERENCE="$2"
            else
              VIASH_PAR_REFERENCE="$VIASH_PAR_REFERENCE;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --reference_genome. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --transcriptome_annotation)
            [ -n "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ] && ViashError Bad arguments for option \'--transcriptome_annotation\': \'$VIASH_PAR_TRANSCRIPTOME_ANNOTATION\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_TRANSCRIPTOME_ANNOTATION="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --transcriptome_annotation. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --transcriptome_annotation=*)
            [ -n "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ] && ViashError Bad arguments for option \'--transcriptome_annotation=*\': \'$VIASH_PAR_TRANSCRIPTOME_ANNOTATION\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_TRANSCRIPTOME_ANNOTATION=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        -t)
            [ -n "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ] && ViashError Bad arguments for option \'-t\': \'$VIASH_PAR_TRANSCRIPTOME_ANNOTATION\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_TRANSCRIPTOME_ANNOTATION="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -t. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --abseq_reference)
            if [ -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
              VIASH_PAR_ABSEQ_REFERENCE="$2"
            else
              VIASH_PAR_ABSEQ_REFERENCE="$VIASH_PAR_ABSEQ_REFERENCE;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --abseq_reference. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --abseq_reference=*)
            if [ -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
              VIASH_PAR_ABSEQ_REFERENCE=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_ABSEQ_REFERENCE="$VIASH_PAR_ABSEQ_REFERENCE;"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        -a)
            if [ -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
              VIASH_PAR_ABSEQ_REFERENCE="$2"
            else
              VIASH_PAR_ABSEQ_REFERENCE="$VIASH_PAR_ABSEQ_REFERENCE;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -a. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --supplemental_reference)
            if [ -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$2"
            else
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$VIASH_PAR_SUPPLEMENTAL_REFERENCE;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --supplemental_reference. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --supplemental_reference=*)
            if [ -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
              VIASH_PAR_SUPPLEMENTAL_REFERENCE=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$VIASH_PAR_SUPPLEMENTAL_REFERENCE;"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        -s)
            if [ -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$2"
            else
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$VIASH_PAR_SUPPLEMENTAL_REFERENCE;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -s. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --sample_prefix)
            [ -n "$VIASH_PAR_SAMPLE_PREFIX" ] && ViashError Bad arguments for option \'--sample_prefix\': \'$VIASH_PAR_SAMPLE_PREFIX\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SAMPLE_PREFIX="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --sample_prefix. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --sample_prefix=*)
            [ -n "$VIASH_PAR_SAMPLE_PREFIX" ] && ViashError Bad arguments for option \'--sample_prefix=*\': \'$VIASH_PAR_SAMPLE_PREFIX\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SAMPLE_PREFIX=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --output)
            [ -n "$VIASH_PAR_OUTPUT" ] && ViashError Bad arguments for option \'--output\': \'$VIASH_PAR_OUTPUT\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_OUTPUT="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --output. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --output=*)
            [ -n "$VIASH_PAR_OUTPUT" ] && ViashError Bad arguments for option \'--output=*\': \'$VIASH_PAR_OUTPUT\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_OUTPUT=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        -o)
            [ -n "$VIASH_PAR_OUTPUT" ] && ViashError Bad arguments for option \'-o\': \'$VIASH_PAR_OUTPUT\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_OUTPUT="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -o. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --putative_cell_call)
            [ -n "$VIASH_PAR_PUTATIVE_CELL_CALL" ] && ViashError Bad arguments for option \'--putative_cell_call\': \'$VIASH_PAR_PUTATIVE_CELL_CALL\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PUTATIVE_CELL_CALL="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --putative_cell_call. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --putative_cell_call=*)
            [ -n "$VIASH_PAR_PUTATIVE_CELL_CALL" ] && ViashError Bad arguments for option \'--putative_cell_call=*\': \'$VIASH_PAR_PUTATIVE_CELL_CALL\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PUTATIVE_CELL_CALL=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --exact_cell_count)
            [ -n "$VIASH_PAR_EXACT_CELL_COUNT" ] && ViashError Bad arguments for option \'--exact_cell_count\': \'$VIASH_PAR_EXACT_CELL_COUNT\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_EXACT_CELL_COUNT="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --exact_cell_count. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --exact_cell_count=*)
            [ -n "$VIASH_PAR_EXACT_CELL_COUNT" ] && ViashError Bad arguments for option \'--exact_cell_count=*\': \'$VIASH_PAR_EXACT_CELL_COUNT\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_EXACT_CELL_COUNT=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --disable_putative_calling)
            [ -n "$VIASH_PAR_DISABLE_PUTATIVE_CALLING" ] && ViashError Bad arguments for option \'--disable_putative_calling\': \'$VIASH_PAR_DISABLE_PUTATIVE_CALLING\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_DISABLE_PUTATIVE_CALLING=true
            shift 1
            ;;
        --subsample)
            [ -n "$VIASH_PAR_SUBSAMPLE" ] && ViashError Bad arguments for option \'--subsample\': \'$VIASH_PAR_SUBSAMPLE\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SUBSAMPLE="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --subsample. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --subsample=*)
            [ -n "$VIASH_PAR_SUBSAMPLE" ] && ViashError Bad arguments for option \'--subsample=*\': \'$VIASH_PAR_SUBSAMPLE\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SUBSAMPLE=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --subsample_seed)
            [ -n "$VIASH_PAR_SUBSAMPLE_SEED" ] && ViashError Bad arguments for option \'--subsample_seed\': \'$VIASH_PAR_SUBSAMPLE_SEED\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SUBSAMPLE_SEED="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --subsample_seed. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --subsample_seed=*)
            [ -n "$VIASH_PAR_SUBSAMPLE_SEED" ] && ViashError Bad arguments for option \'--subsample_seed=*\': \'$VIASH_PAR_SUBSAMPLE_SEED\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SUBSAMPLE_SEED=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --sample_tags_version)
            [ -n "$VIASH_PAR_SAMPLE_TAGS_VERSION" ] && ViashError Bad arguments for option \'--sample_tags_version\': \'$VIASH_PAR_SAMPLE_TAGS_VERSION\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SAMPLE_TAGS_VERSION="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --sample_tags_version. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --sample_tags_version=*)
            [ -n "$VIASH_PAR_SAMPLE_TAGS_VERSION" ] && ViashError Bad arguments for option \'--sample_tags_version=*\': \'$VIASH_PAR_SAMPLE_TAGS_VERSION\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_SAMPLE_TAGS_VERSION=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --tag_names)
            if [ -z "$VIASH_PAR_TAG_NAMES" ]; then
              VIASH_PAR_TAG_NAMES="$2"
            else
              VIASH_PAR_TAG_NAMES="$VIASH_PAR_TAG_NAMES;""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --tag_names. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --tag_names=*)
            if [ -z "$VIASH_PAR_TAG_NAMES" ]; then
              VIASH_PAR_TAG_NAMES=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_TAG_NAMES="$VIASH_PAR_TAG_NAMES;"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        --vdj_version)
            [ -n "$VIASH_PAR_VDJ_VERSION" ] && ViashError Bad arguments for option \'--vdj_version\': \'$VIASH_PAR_VDJ_VERSION\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_VDJ_VERSION="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --vdj_version. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --vdj_version=*)
            [ -n "$VIASH_PAR_VDJ_VERSION" ] && ViashError Bad arguments for option \'--vdj_version=*\': \'$VIASH_PAR_VDJ_VERSION\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_VDJ_VERSION=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --parallel)
            [ -n "$VIASH_PAR_PARALLEL" ] && ViashError Bad arguments for option \'--parallel\': \'$VIASH_PAR_PARALLEL\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PARALLEL="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --parallel. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --parallel=*)
            [ -n "$VIASH_PAR_PARALLEL" ] && ViashError Bad arguments for option \'--parallel=*\': \'$VIASH_PAR_PARALLEL\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_PARALLEL=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --timestamps)
            [ -n "$VIASH_PAR_TIMESTAMPS" ] && ViashError Bad arguments for option \'--timestamps\': \'$VIASH_PAR_TIMESTAMPS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_TIMESTAMPS=true
            shift 1
            ;;
        --dryrun)
            [ -n "$VIASH_PAR_DRYRUN" ] && ViashError Bad arguments for option \'--dryrun\': \'$VIASH_PAR_DRYRUN\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_PAR_DRYRUN=true
            shift 1
            ;;
        ---setup)
            VIASH_MODE='docker_setup'
            VIASH_DOCKER_SETUP_STRATEGY="$2"
            shift 1
            ;;
        ---setup=*)
            VIASH_MODE='docker_setup'
            VIASH_DOCKER_SETUP_STRATEGY="$(ViashRemoveFlags "$1")"
            shift 2
            ;;
        ---dockerfile)
            ViashDockerfile
            exit 0
            ;;
        ---v|---volume)
            VIASH_EXTRA_MOUNTS+=("--volume='$2'")
            shift 2
            ;;
        ---volume=*)
            VIASH_EXTRA_MOUNTS+=("--volume='$(ViashRemoveFlags "$2")'")
            shift 1
            ;;
        ---debug)
            VIASH_MODE='docker_debug'
            shift 1
            ;;
        ---cpus)
            [ -n "$VIASH_META_CPUS" ] && ViashError Bad arguments for option \'---cpus\': \'$VIASH_META_CPUS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_CPUS="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to ---cpus. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        ---cpus=*)
            [ -n "$VIASH_META_CPUS" ] && ViashError Bad arguments for option \'---cpus=*\': \'$VIASH_META_CPUS\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_CPUS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        ---memory)
            [ -n "$VIASH_META_MEMORY" ] && ViashError Bad arguments for option \'---memory\': \'$VIASH_META_MEMORY\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_MEMORY="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to ---memory. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        ---memory=*)
            [ -n "$VIASH_META_MEMORY" ] && ViashError Bad arguments for option \'---memory=*\': \'$VIASH_META_MEMORY\' \& \'$2\' - you should provide exactly one argument for this option. && exit 1
            VIASH_META_MEMORY=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        *)  # positional arg or unknown option
            # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
            VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
            [[ $1 == -* ]] && ViashWarning $1 looks like a parameter but is not a defined parameter and will instead be treated as a positional argument. Use "--help" to get more information on the parameters.
            shift # past argument
            ;;
    esac
done

# parse positional parameters
eval set -- $VIASH_POSITIONAL_ARGS


ViashDockerInstallationCheck

if [ $VIASH_MODE == "docker_setup" ]; then
  ViashDockerSetup 'ghcr.io/openpipelines-bio/mapping/bd_rhapsody:1.0.0' "$VIASH_DOCKER_SETUP_STRATEGY"
  exit 0
fi
ViashDockerSetup 'ghcr.io/openpipelines-bio/mapping/bd_rhapsody:1.0.0' ifneedbepullelsecachedbuild

if [ $VIASH_MODE == "docker_debug" ]; then
  ViashNotice "+ docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t 'ghcr.io/openpipelines-bio/mapping/bd_rhapsody:1.0.0'"
  docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t 'ghcr.io/openpipelines-bio/mapping/bd_rhapsody:1.0.0'
  exit 0
fi

# setting computational defaults

# helper function for parsing memory strings
function ViashMemoryAsBytes {
  local memory=`echo "$1" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]'`
  local memory_regex='^([0-9]+)([kmgtp]b?|b)$'
  if [[ $memory =~ $memory_regex ]]; then
    local number=${memory/[^0-9]*/}
    local symbol=${memory/*[0-9]/}
    
    case $symbol in
      b)      memory_b=$number ;;
      kb|k)   memory_b=$(( $number * 1024 )) ;;
      mb|m)   memory_b=$(( $number * 1024 * 1024 )) ;;
      gb|g)   memory_b=$(( $number * 1024 * 1024 * 1024 )) ;;
      tb|t)   memory_b=$(( $number * 1024 * 1024 * 1024 * 1024 )) ;;
      pb|p)   memory_b=$(( $number * 1024 * 1024 * 1024 * 1024 * 1024 )) ;;
    esac
    echo "$memory_b"
  fi
}
# compute memory in different units
if [ ! -z ${VIASH_META_MEMORY+x} ]; then
  VIASH_META_MEMORY_B=`ViashMemoryAsBytes $VIASH_META_MEMORY`
  # do not define other variables if memory_b is an empty string
  if [ ! -z "$VIASH_META_MEMORY_B" ]; then
    VIASH_META_MEMORY_KB=$(( ($VIASH_META_MEMORY_B+1023) / 1024 ))
    VIASH_META_MEMORY_MB=$(( ($VIASH_META_MEMORY_KB+1023) / 1024 ))
    VIASH_META_MEMORY_GB=$(( ($VIASH_META_MEMORY_MB+1023) / 1024 ))
    VIASH_META_MEMORY_TB=$(( ($VIASH_META_MEMORY_GB+1023) / 1024 ))
    VIASH_META_MEMORY_PB=$(( ($VIASH_META_MEMORY_TB+1023) / 1024 ))
  else
    # unset memory if string is empty
    unset $VIASH_META_MEMORY_B
  fi
fi
# unset nproc if string is empty
if [ -z "$VIASH_META_CPUS" ]; then
  unset $VIASH_META_CPUS
fi


# check whether required parameters exist
if [ -z ${VIASH_PAR_MODE+x} ]; then
  ViashError '--mode' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_PAR_INPUT+x} ]; then
  ViashError '--input' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_PAR_REFERENCE+x} ]; then
  ViashError '--reference' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_PAR_OUTPUT+x} ]; then
  ViashError '--output' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_FUNCTIONALITY_NAME+x} ]; then
  ViashError 'functionality_name' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_RESOURCES_DIR+x} ]; then
  ViashError 'resources_dir' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_EXECUTABLE+x} ]; then
  ViashError 'executable' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_CONFIG+x} ]; then
  ViashError 'config' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z ${VIASH_META_TEMP_DIR+x} ]; then
  ViashError 'temp_dir' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi

# filling in defaults
if [ -z ${VIASH_PAR_SAMPLE_PREFIX+x} ]; then
  VIASH_PAR_SAMPLE_PREFIX="sample"
fi
if [ -z ${VIASH_PAR_DISABLE_PUTATIVE_CALLING+x} ]; then
  VIASH_PAR_DISABLE_PUTATIVE_CALLING="false"
fi
if [ -z ${VIASH_PAR_PARALLEL+x} ]; then
  VIASH_PAR_PARALLEL="true"
fi
if [ -z ${VIASH_PAR_TIMESTAMPS+x} ]; then
  VIASH_PAR_TIMESTAMPS="false"
fi
if [ -z ${VIASH_PAR_DRYRUN+x} ]; then
  VIASH_PAR_DRYRUN="false"
fi

# check whether required files exist
if [ ! -z "$VIASH_PAR_INPUT" ]; then
  IFS=';'
  set -f
  for file in $VIASH_PAR_INPUT; do
    unset IFS
    if [ ! -e "$file" ]; then
      ViashError "Input file '$file' does not exist."
      exit 1
    fi
  done
  set +f
fi
if [ ! -z "$VIASH_PAR_REFERENCE" ]; then
  IFS=';'
  set -f
  for file in $VIASH_PAR_REFERENCE; do
    unset IFS
    if [ ! -e "$file" ]; then
      ViashError "Input file '$file' does not exist."
      exit 1
    fi
  done
  set +f
fi
if [ ! -z "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ] && [ ! -e "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ]; then
  ViashError "Input file '$VIASH_PAR_TRANSCRIPTOME_ANNOTATION' does not exist."
  exit 1
fi
if [ ! -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
  IFS=';'
  set -f
  for file in $VIASH_PAR_ABSEQ_REFERENCE; do
    unset IFS
    if [ ! -e "$file" ]; then
      ViashError "Input file '$file' does not exist."
      exit 1
    fi
  done
  set +f
fi
if [ ! -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
  IFS=';'
  set -f
  for file in $VIASH_PAR_SUPPLEMENTAL_REFERENCE; do
    unset IFS
    if [ ! -e "$file" ]; then
      ViashError "Input file '$file' does not exist."
      exit 1
    fi
  done
  set +f
fi

# check whether parameters values are of the right type
if [[ -n "$VIASH_PAR_EXACT_CELL_COUNT" ]]; then
  if ! [[ "$VIASH_PAR_EXACT_CELL_COUNT" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError '--exact_cell_count' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_DISABLE_PUTATIVE_CALLING" ]]; then
  if ! [[ "$VIASH_PAR_DISABLE_PUTATIVE_CALLING" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--disable_putative_calling' has to be a boolean_true. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_SUBSAMPLE" ]]; then
  if ! [[ "$VIASH_PAR_SUBSAMPLE" =~ ^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$ ]]; then
    ViashError '--subsample' has to be a double. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_SUBSAMPLE_SEED" ]]; then
  if ! [[ "$VIASH_PAR_SUBSAMPLE_SEED" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError '--subsample_seed' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_PARALLEL" ]]; then
  if ! [[ "$VIASH_PAR_PARALLEL" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--parallel' has to be a boolean. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_TIMESTAMPS" ]]; then
  if ! [[ "$VIASH_PAR_TIMESTAMPS" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--timestamps' has to be a boolean_true. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_PAR_DRYRUN" ]]; then
  if ! [[ "$VIASH_PAR_DRYRUN" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--dryrun' has to be a boolean_true. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_CPUS" ]]; then
  if ! [[ "$VIASH_META_CPUS" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'cpus' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_B" ]]; then
  if ! [[ "$VIASH_META_MEMORY_B" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_b' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_KB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_KB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_kb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_MB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_MB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_mb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_GB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_GB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_gb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_TB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_TB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_tb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi
if [[ -n "$VIASH_META_MEMORY_PB" ]]; then
  if ! [[ "$VIASH_META_MEMORY_PB" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError 'memory_pb' has to be a long. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

# check whether value is belongs to a set of choices
if [ ! -z "$VIASH_PAR_MODE" ]; then
  VIASH_PAR_MODE_CHOICES=("wta:targeted")
  IFS=':'
  set -f
  if ! [[ ":${VIASH_PAR_MODE_CHOICES[*]}:" =~ ":$VIASH_PAR_MODE:" ]]; then
    ViashError '--mode' specified value of \'$VIASH_PAR_MODE\' is not in the list of allowed values. Use "--help" to get more information on the parameters.
    exit 1
  fi
  set +f
  unset IFS
fi

if [ ! -z "$VIASH_PAR_PUTATIVE_CELL_CALL" ]; then
  VIASH_PAR_PUTATIVE_CELL_CALL_CHOICES=("mRNA:AbSeq_Experimental")
  IFS=':'
  set -f
  if ! [[ ":${VIASH_PAR_PUTATIVE_CELL_CALL_CHOICES[*]}:" =~ ":$VIASH_PAR_PUTATIVE_CELL_CALL:" ]]; then
    ViashError '--putative_cell_call' specified value of \'$VIASH_PAR_PUTATIVE_CELL_CALL\' is not in the list of allowed values. Use "--help" to get more information on the parameters.
    exit 1
  fi
  set +f
  unset IFS
fi

if [ ! -z "$VIASH_PAR_SAMPLE_TAGS_VERSION" ]; then
  VIASH_PAR_SAMPLE_TAGS_VERSION_CHOICES=("human:hs:mouse:mm")
  IFS=':'
  set -f
  if ! [[ ":${VIASH_PAR_SAMPLE_TAGS_VERSION_CHOICES[*]}:" =~ ":$VIASH_PAR_SAMPLE_TAGS_VERSION:" ]]; then
    ViashError '--sample_tags_version' specified value of \'$VIASH_PAR_SAMPLE_TAGS_VERSION\' is not in the list of allowed values. Use "--help" to get more information on the parameters.
    exit 1
  fi
  set +f
  unset IFS
fi

if [ ! -z "$VIASH_PAR_VDJ_VERSION" ]; then
  VIASH_PAR_VDJ_VERSION_CHOICES=("human:mouse:humanBCR:humanBCR:humanTCR:mouseBCR")
  IFS=':'
  set -f
  if ! [[ ":${VIASH_PAR_VDJ_VERSION_CHOICES[*]}:" =~ ":$VIASH_PAR_VDJ_VERSION:" ]]; then
    ViashError '--vdj_version' specified value of \'$VIASH_PAR_VDJ_VERSION\' is not in the list of allowed values. Use "--help" to get more information on the parameters.
    exit 1
  fi
  set +f
  unset IFS
fi

# create parent directories of output files, if so desired
if [ ! -z "$VIASH_PAR_OUTPUT" ] && [ ! -d "$(dirname "$VIASH_PAR_OUTPUT")" ]; then
  mkdir -p "$(dirname "$VIASH_PAR_OUTPUT")"
fi

# detect volumes from file arguments
VIASH_CHOWN_VARS=()
if [ ! -z "$VIASH_PAR_INPUT" ]; then
  VIASH_TEST_INPUT=()
  IFS=';'
  for var in $VIASH_PAR_INPUT; do
    unset IFS
    VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$var")" )
    var=$(ViashAutodetectMount "$var")
    VIASH_TEST_INPUT+=( "$var" )
  done
  VIASH_PAR_INPUT=$(IFS=';' ; echo "${VIASH_TEST_INPUT[*]}")
fi
if [ ! -z "$VIASH_PAR_REFERENCE" ]; then
  VIASH_TEST_REFERENCE=()
  IFS=';'
  for var in $VIASH_PAR_REFERENCE; do
    unset IFS
    VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$var")" )
    var=$(ViashAutodetectMount "$var")
    VIASH_TEST_REFERENCE+=( "$var" )
  done
  VIASH_PAR_REFERENCE=$(IFS=';' ; echo "${VIASH_TEST_REFERENCE[*]}")
fi
if [ ! -z "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION")" )
  VIASH_PAR_TRANSCRIPTOME_ANNOTATION=$(ViashAutodetectMount "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION")
fi
if [ ! -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
  VIASH_TEST_ABSEQ_REFERENCE=()
  IFS=';'
  for var in $VIASH_PAR_ABSEQ_REFERENCE; do
    unset IFS
    VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$var")" )
    var=$(ViashAutodetectMount "$var")
    VIASH_TEST_ABSEQ_REFERENCE+=( "$var" )
  done
  VIASH_PAR_ABSEQ_REFERENCE=$(IFS=';' ; echo "${VIASH_TEST_ABSEQ_REFERENCE[*]}")
fi
if [ ! -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
  VIASH_TEST_SUPPLEMENTAL_REFERENCE=()
  IFS=';'
  for var in $VIASH_PAR_SUPPLEMENTAL_REFERENCE; do
    unset IFS
    VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$var")" )
    var=$(ViashAutodetectMount "$var")
    VIASH_TEST_SUPPLEMENTAL_REFERENCE+=( "$var" )
  done
  VIASH_PAR_SUPPLEMENTAL_REFERENCE=$(IFS=';' ; echo "${VIASH_TEST_SUPPLEMENTAL_REFERENCE[*]}")
fi
if [ ! -z "$VIASH_PAR_OUTPUT" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_PAR_OUTPUT")" )
  VIASH_PAR_OUTPUT=$(ViashAutodetectMount "$VIASH_PAR_OUTPUT")
  VIASH_CHOWN_VARS+=( "$VIASH_PAR_OUTPUT" )
fi
if [ ! -z "$VIASH_META_RESOURCES_DIR" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_META_RESOURCES_DIR")" )
  VIASH_META_RESOURCES_DIR=$(ViashAutodetectMount "$VIASH_META_RESOURCES_DIR")
fi
if [ ! -z "$VIASH_META_EXECUTABLE" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_META_EXECUTABLE")" )
  VIASH_META_EXECUTABLE=$(ViashAutodetectMount "$VIASH_META_EXECUTABLE")
fi
if [ ! -z "$VIASH_META_CONFIG" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_META_CONFIG")" )
  VIASH_META_CONFIG=$(ViashAutodetectMount "$VIASH_META_CONFIG")
fi
if [ ! -z "$VIASH_META_TEMP_DIR" ]; then
  VIASH_EXTRA_MOUNTS+=( "$(ViashAutodetectMountArg "$VIASH_META_TEMP_DIR")" )
  VIASH_META_TEMP_DIR=$(ViashAutodetectMount "$VIASH_META_TEMP_DIR")
fi

# get unique mounts
VIASH_UNIQUE_MOUNTS=($(for val in "${VIASH_EXTRA_MOUNTS[@]}"; do echo "$val"; done | sort -u))

# change file ownership
function ViashPerformChown {
  if (( ${#VIASH_CHOWN_VARS[@]} )); then
    set +e
    eval docker run --entrypoint=bash -i --rm ${VIASH_UNIQUE_MOUNTS[@]} ghcr.io/openpipelines-bio/mapping/bd_rhapsody:1.0.0 -c "'chown $(id -u):$(id -g) --silent --recursive ${VIASH_CHOWN_VARS[@]}'"
    set -e
  fi
}
trap ViashPerformChown EXIT

# helper function for filling in extra docker args
VIASH_EXTRA_DOCKER_ARGS=""
if [ ! -z "$VIASH_META_MEMORY_MB" ]; then
  VIASH_EXTRA_DOCKER_ARGS="$VIASH_EXTRA_DOCKER_ARGS --memory=${VIASH_META_MEMORY_MB}m"
fi
if [ ! -z "$VIASH_META_CPUS" ]; then
  VIASH_EXTRA_DOCKER_ARGS="$VIASH_EXTRA_DOCKER_ARGS --cpus=${VIASH_META_CPUS}"
fi


# set dependency paths


ViashDebug "Running command: $(echo docker run --entrypoint=bash -i --rm ${VIASH_UNIQUE_MOUNTS[@]} $VIASH_EXTRA_DOCKER_ARGS ghcr.io/openpipelines-bio/mapping/bd_rhapsody:1.0.0)"
cat << VIASHEOF | eval docker run --entrypoint=bash -i --rm ${VIASH_UNIQUE_MOUNTS[@]} $VIASH_EXTRA_DOCKER_ARGS ghcr.io/openpipelines-bio/mapping/bd_rhapsody:1.0.0
set -e
tempscript=\$(mktemp "$VIASH_META_TEMP_DIR/viash-run-bd_rhapsody-XXXXXX").py
function clean_up {
  rm "\$tempscript"
}
function interrupt {
  echo -e "\nCTRL-C Pressed..."
  exit 1
}
trap clean_up EXIT
trap interrupt INT SIGINT
cat > "\$tempscript" << 'VIASHMAIN'
import os
import re
import subprocess
import tempfile
import sys
from typing import Any
import pandas as pd
import gzip
import shutil

## VIASH START
# The following code has been auto-generated by Viash.
par = {
  'mode': $( if [ ! -z ${VIASH_PAR_MODE+x} ]; then echo "r'${VIASH_PAR_MODE//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'input': $( if [ ! -z ${VIASH_PAR_INPUT+x} ]; then echo "r'${VIASH_PAR_INPUT//\'/\'\"\'\"r\'}'.split(';')"; else echo None; fi ),
  'reference': $( if [ ! -z ${VIASH_PAR_REFERENCE+x} ]; then echo "r'${VIASH_PAR_REFERENCE//\'/\'\"\'\"r\'}'.split(';')"; else echo None; fi ),
  'transcriptome_annotation': $( if [ ! -z ${VIASH_PAR_TRANSCRIPTOME_ANNOTATION+x} ]; then echo "r'${VIASH_PAR_TRANSCRIPTOME_ANNOTATION//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'abseq_reference': $( if [ ! -z ${VIASH_PAR_ABSEQ_REFERENCE+x} ]; then echo "r'${VIASH_PAR_ABSEQ_REFERENCE//\'/\'\"\'\"r\'}'.split(';')"; else echo None; fi ),
  'supplemental_reference': $( if [ ! -z ${VIASH_PAR_SUPPLEMENTAL_REFERENCE+x} ]; then echo "r'${VIASH_PAR_SUPPLEMENTAL_REFERENCE//\'/\'\"\'\"r\'}'.split(';')"; else echo None; fi ),
  'sample_prefix': $( if [ ! -z ${VIASH_PAR_SAMPLE_PREFIX+x} ]; then echo "r'${VIASH_PAR_SAMPLE_PREFIX//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'output': $( if [ ! -z ${VIASH_PAR_OUTPUT+x} ]; then echo "r'${VIASH_PAR_OUTPUT//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'putative_cell_call': $( if [ ! -z ${VIASH_PAR_PUTATIVE_CELL_CALL+x} ]; then echo "r'${VIASH_PAR_PUTATIVE_CELL_CALL//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'exact_cell_count': $( if [ ! -z ${VIASH_PAR_EXACT_CELL_COUNT+x} ]; then echo "int(r'${VIASH_PAR_EXACT_CELL_COUNT//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'disable_putative_calling': $( if [ ! -z ${VIASH_PAR_DISABLE_PUTATIVE_CALLING+x} ]; then echo "r'${VIASH_PAR_DISABLE_PUTATIVE_CALLING//\'/\'\"\'\"r\'}'.lower() == 'true'"; else echo None; fi ),
  'subsample': $( if [ ! -z ${VIASH_PAR_SUBSAMPLE+x} ]; then echo "float(r'${VIASH_PAR_SUBSAMPLE//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'subsample_seed': $( if [ ! -z ${VIASH_PAR_SUBSAMPLE_SEED+x} ]; then echo "int(r'${VIASH_PAR_SUBSAMPLE_SEED//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'sample_tags_version': $( if [ ! -z ${VIASH_PAR_SAMPLE_TAGS_VERSION+x} ]; then echo "r'${VIASH_PAR_SAMPLE_TAGS_VERSION//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'tag_names': $( if [ ! -z ${VIASH_PAR_TAG_NAMES+x} ]; then echo "r'${VIASH_PAR_TAG_NAMES//\'/\'\"\'\"r\'}'.split(';')"; else echo None; fi ),
  'vdj_version': $( if [ ! -z ${VIASH_PAR_VDJ_VERSION+x} ]; then echo "r'${VIASH_PAR_VDJ_VERSION//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'parallel': $( if [ ! -z ${VIASH_PAR_PARALLEL+x} ]; then echo "r'${VIASH_PAR_PARALLEL//\'/\'\"\'\"r\'}'.lower() == 'true'"; else echo None; fi ),
  'timestamps': $( if [ ! -z ${VIASH_PAR_TIMESTAMPS+x} ]; then echo "r'${VIASH_PAR_TIMESTAMPS//\'/\'\"\'\"r\'}'.lower() == 'true'"; else echo None; fi ),
  'dryrun': $( if [ ! -z ${VIASH_PAR_DRYRUN+x} ]; then echo "r'${VIASH_PAR_DRYRUN//\'/\'\"\'\"r\'}'.lower() == 'true'"; else echo None; fi )
}
meta = {
  'functionality_name': $( if [ ! -z ${VIASH_META_FUNCTIONALITY_NAME+x} ]; then echo "r'${VIASH_META_FUNCTIONALITY_NAME//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'resources_dir': $( if [ ! -z ${VIASH_META_RESOURCES_DIR+x} ]; then echo "r'${VIASH_META_RESOURCES_DIR//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'executable': $( if [ ! -z ${VIASH_META_EXECUTABLE+x} ]; then echo "r'${VIASH_META_EXECUTABLE//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'config': $( if [ ! -z ${VIASH_META_CONFIG+x} ]; then echo "r'${VIASH_META_CONFIG//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'temp_dir': $( if [ ! -z ${VIASH_META_TEMP_DIR+x} ]; then echo "r'${VIASH_META_TEMP_DIR//\'/\'\"\'\"r\'}'"; else echo None; fi ),
  'cpus': $( if [ ! -z ${VIASH_META_CPUS+x} ]; then echo "int(r'${VIASH_META_CPUS//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_b': $( if [ ! -z ${VIASH_META_MEMORY_B+x} ]; then echo "int(r'${VIASH_META_MEMORY_B//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_kb': $( if [ ! -z ${VIASH_META_MEMORY_KB+x} ]; then echo "int(r'${VIASH_META_MEMORY_KB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_mb': $( if [ ! -z ${VIASH_META_MEMORY_MB+x} ]; then echo "int(r'${VIASH_META_MEMORY_MB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_gb': $( if [ ! -z ${VIASH_META_MEMORY_GB+x} ]; then echo "int(r'${VIASH_META_MEMORY_GB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_tb': $( if [ ! -z ${VIASH_META_MEMORY_TB+x} ]; then echo "int(r'${VIASH_META_MEMORY_TB//\'/\'\"\'\"r\'}')"; else echo None; fi ),
  'memory_pb': $( if [ ! -z ${VIASH_META_MEMORY_PB+x} ]; then echo "int(r'${VIASH_META_MEMORY_PB//\'/\'\"\'\"r\'}')"; else echo None; fi )
}
dep = {
  
}

## VIASH END

sys.path.append(meta["resources_dir"])
# START TEMPORARY WORKAROUND setup_logger
# reason: resources aren't available when using Nextflow fusion
# from setup_logger import setup_logger
def setup_logger():
    import logging
    from sys import stdout

    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    console_handler = logging.StreamHandler(stdout)
    logFormatter = logging.Formatter("%(asctime)s %(levelname)-8s %(message)s")
    console_handler.setFormatter(logFormatter)
    logger.addHandler(console_handler)

    return logger
# END TEMPORARY WORKAROUND setup_logger
logger = setup_logger()

def is_gz_file(filepath):
    with open(filepath, 'rb') as test_f:
        return test_f.read(2) == b'\\x1f\\x8b'

def strip_margin(text: str) -> str:
    return re.sub('(\\n?)[ \\t]*\\|', '\\\\1', text)

def process_params(par: dict[str, Any]) -> str:
    # check input parameters
    assert par["input"] is not None, "Pass at least one set of inputs to --input."
    if par["mode"] == "wta":
        assert len(par["reference"]) == 1, "When mode is \\"wta\\", --reference should be length 1"
        assert par["transcriptome_annotation"] is not None, "When mode is \\"wta\\", --transcriptome_annotation should be defined"
    elif par["mode"] == "targeted":
        assert par["transcriptome_annotation"] is None, "When mode is \\"targeted\\", --transcriptome_annotation should be undefined"
        assert par["supplemental_reference"] is None, "When mode is \\"targeted\\", --supplemental_reference should be undefined"

    # checking sample prefix
    if re.match("[^A-Za-z0-9]", par["sample_prefix"]):
        logger.warning("--sample_prefix should only consist of letters, numbers or hyphens. Replacing all '[^A-Za-z0-9]' with '-'.")
        par["sample_prefix"] = re.sub("[^A-Za-z0-9\\\\-]", "-", par["sample_prefix"])

    # if par_input is a directory, look for fastq files
    if len(par["input"]) == 1 and os.path.isdir(par["input"][0]):
        par["input"] = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(par["input"]) for f in filenames if re.match(r'.*\\.fastq.gz', f) ]

    # use absolute paths
    par["input"] = [ os.path.abspath(f) for f in par["input"] ]
    if par["reference"]:
        par["reference"] = [ os.path.abspath(f) for f in par["reference"] ]
    if par["transcriptome_annotation"]:
        par["transcriptome_annotation"] = os.path.abspath(par["transcriptome_annotation"])
    if par["abseq_reference"]:
        par["abseq_reference"] = [ os.path.abspath(f) for f in par["abseq_reference"] ]
    if par["supplemental_reference"]:
        par["supplemental_reference"] = [ os.path.abspath(f) for f in par["supplemental_reference"] ]
    par["output"] = os.path.abspath(par["output"])
    
    return par

def generate_config(par: dict[str, Any]) -> str:
    content_list = [strip_margin(f"""\\
        |#!/usr/bin/env cwl-runner
        |
        |cwl:tool: rhapsody
        |
        |# This is a YML file used to specify the inputs for a BD Genomics {"WTA" if par["mode"] == "wta" else "Targeted" } Rhapsody Analysis pipeline run. See the
        |# BD Genomics Analysis Setup User Guide (Doc ID: 47383) for more details.
        |
        |## Reads (required) - Path to your read files in the FASTQ.GZ format. You may specify as many R1/R2 read pairs as you want.
        |Reads:
        |""")]

    for file in par["input"]:
        content_list.append(strip_margin(f"""\\
            | - class: File
            |   location: "{file}"
            |"""))

    if par["reference"] and par["mode"] == "wta":
        content_list.append(strip_margin(f"""\\
            |
            |## Reference_Genome (required) - Path to STAR index for tar.gz format. See Doc ID: 47383 for instructions to obtain pre-built STAR index file.
            |Reference_Genome:
            |   class: File
            |   location: "{par["reference"][0]}"
            |"""))

    if par["reference"] and par["mode"] == "targeted":
        content_list.append(strip_margin(f"""\\
            |
            |## Reference (optional) - Path to mRNA reference file for pre-designed, supplemental, or custom panel, in FASTA format.
            |Reference:
            |"""))
        for file in par["reference"]:
            content_list.append(strip_margin(f"""\\
                | - class: File
                |   location: {file}
                |"""))

    if par["transcriptome_annotation"]:
        content_list.append(strip_margin(f"""\\
            |
            |## Transcriptome_Annotation (required) - Path to GTF annotation file
            |Transcriptome_Annotation:
            |   class: File
            |   location: "{par["transcriptome_annotation"]}"
            |"""))

    if par["abseq_reference"]:
        content_list.append(strip_margin(f"""\\
            |
            |## AbSeq_Reference (optional) - Path to the AbSeq reference file in FASTA format.  Only needed if BD AbSeq Ab-Oligos are used.
            |AbSeq_Reference:
            |"""))
        for file in par["abseq_reference"]:
            content_list.append(strip_margin(f"""\\
                | - class: File
                |   location: {file}
                |"""))

    if par["supplemental_reference"]:
        content_list.append(strip_margin(f"""\\
            |
            |## Supplemental_Reference (optional) - Path to the supplemental reference file in FASTA format.  Only needed if there are additional transgene sequences used in the experiment.
            |Supplemental_Reference:
            |"""))
        for file in par["supplemental_reference"]:
            content_list.append(strip_margin(f"""\\
                | - class: File
                |   location: {file}
                |"""))

    ## Putative Cell Calling Settings
    content_list.append(strip_margin(f"""\\
        |
        |####################################
        |## Putative Cell Calling Settings ##
        |####################################
        |"""))

    if par["putative_cell_call"]:
        content_list.append(strip_margin(f"""\\
            |## Putative cell calling dataset (optional) - Specify the dataset to be used for putative cell calling: mRNA or AbSeq_Experimental.
            |## For putative cell calling using an AbSeq dataset, please provide an AbSeq_Reference fasta file above.
            |## By default, the mRNA data will be used for putative cell calling.
            |Putative_Cell_Call: {par["putative_cell_call"]}
            |"""))

    if par["exact_cell_count"]:
        content_list.append(strip_margin(f"""\\
            |## Exact cell count (optional) - Set a specific number (>=1) of cells as putative, based on those with the highest error-corrected read count
            |Exact_Cell_Count: {par["exact_cell_count"]}
            |"""))

    if par["disable_putative_calling"]:
        content_list.append(strip_margin(f"""\\
            |## Disable Refined Putative Cell Calling (optional) - Determine putative cells using only the basic algorithm (minimum second derivative along the cumulative reads curve).  The refined algorithm attempts to remove false positives and recover false negatives, but may not be ideal for certain complex mixtures of cell types.  Does not apply if Exact Cell Count is set.
            |## The values can be true or false. By default, the refined algorithm is used.
            |Basic_Algo_Only: {str(par["disable_putative_calling"]).lower()}
            |"""))

    ## Subsample Settings
    content_list.append(strip_margin(f"""\\
        |
        |########################
        |## Subsample Settings ##
        |########################
        |"""
    ))

    if par["subsample"]:
        content_list.append(strip_margin(f"""\\
            |## Subsample (optional) - A number >1 or fraction (0 < n < 1) to indicate the number or percentage of reads to subsample.
            |Subsample: {par["subsample"]}
            |"""))

    if par["subsample_seed"]:
        content_list.append(strip_margin(f"""\\
            |## Subsample seed (optional) - A seed for replicating a previous subsampled run.
            |Subsample_seed: {par["subsample_seed"]}
            |"""))


    ## Multiplex options
    content_list.append(strip_margin(f"""\\
        |
        |#######################
        |## Multiplex options ##
        |#######################
        |"""
    ))

    if par["sample_tags_version"]:
        content_list.append(strip_margin(f"""\\
            |## Sample Tags Version (optional) - Specify if multiplexed run: human, hs, mouse or mm
            |Sample_Tags_Version: {par["sample_tags_version"]}
            |"""))

    if par["tag_names"]:
        content_list.append(strip_margin(f"""\\
            |## Tag_Names (optional) - Specify the tag number followed by '-' and the desired sample name to appear in Sample_Tag_Metrics.csv
            |# Do not use the special characters: &, (), [], {{}},  <>, ?, |
            |Tag_Names: [{', '.join(par["tag_names"])}]
            |"""))

    ## VDJ options
    content_list.append(strip_margin(f"""\\
        |
        |#################
        |## VDJ options ##
        |#################
        |"""
    ))

    if par["vdj_version"]:
        content_list.append(strip_margin(f"""\\
            |## VDJ Version (optional) - Specify if VDJ run: human, mouse, humanBCR, humanTCR, mouseBCR, mouseTCR
            |VDJ_Version: {par["vdj_version"]}
            |"""))

    ## VDJ options
    content_list.append(strip_margin(f"""\\
        |
        |########################
        |## Additional Options ##
        |########################
        |"""
    ))

    if par["sample_prefix"]:
        content_list.append(strip_margin(f"""\\
            |## Run Name (optional) -  Specify a run name to use as the output file base name. Use only letters, numbers, or hyphens. Do not use special characters or spaces.
            |Run_Name: {par["sample_prefix"]}
            |"""))

    ## Write config to file
    return ''.join(content_list)

def generate_cwl_file(par: dict[str, Any], meta: dict[str, Any]) -> str:
        # create cwl file (if need be)
    if par["mode"] == "wta":
        orig_cwl_file=os.path.join(meta["resources_dir"], "rhapsody_wta_1.10.1_nodocker.cwl")
    elif par["mode"] == "targeted":
        orig_cwl_file=os.path.join(meta["resources_dir"], "rhapsody_targeted_1.10.1_nodocker.cwl")

    # Inject computational requirements into pipeline
    if meta["memory_mb"] or meta["cpus"]:
        cwl_file = os.path.join(par["output"], "pipeline.cwl")

        # Read in the file
        with open(orig_cwl_file, 'r') as file :
            cwl_data = file.read()

        # Inject computational requirements into pipeline
        if meta["memory_mb"]:
            memory = int(meta["memory_mb"]) - 2000 # keep 2gb for OS
            cwl_data = re.sub('"ramMin": [^\\n]*,\\n', f'"ramMin": {memory},\\n', cwl_data)
        if meta["cpus"]:
            cwl_data = re.sub('"coresMin": [^\\n]*,\\n', f'"coresMin": {meta["cpus"]},\\n', cwl_data)

        # Write the file out again
        with open(cwl_file, 'w') as file:
            file.write(cwl_data)
    else:
        cwl_file = orig_cwl_file

    return cwl_file

def process_fasta(feature_type: str, path: str) -> pd.DataFrame:
    with open(path) as f:
        df = pd.DataFrame(data={
        'feature_type': feature_type,
        'feature_id': [line[1:].strip() for line in f if line[0] == ">"],
        'reference_file': os.path.basename(path),
        })
        return df

def process_gtf(feature_type: str, path: str) -> pd.DataFrame:
    with open(path) as f:
        data = []
        for line in f:
            if not line.startswith("#"):
                attr = dict(item.strip().split(' ') for item in line.split('\\t')[8].strip('\\n').split(';') if item)
                row = {
                    'feature_types': feature_type,
                    'feature_ids': attr["gene_name"].strip("\\""),
                    'reference_file': os.path.basename(path),
                }
            data.append(row)
    df = pd.DataFrame(data)
    df = df.drop_duplicates()
    return df

def extract_feature_types(par: dict[str, Any]):
    feature_types = []

    if par["mode"] == "targeted":
        for file in par["reference"]:
            logger.info(f"Processing reference fasta {file}")
            feature_types.append(process_fasta("Gene Expression", file))

    if par["mode"] == "wta":
        file = par["transcriptome_annotation"]
        logger.info(f"Processing reference gtf {file}")
        feature_types.append(process_gtf("Gene Expression", file))

    if par["abseq_reference"]:
        for file in par["abseq_reference"]:
            logger.info(f"Processing abseq fasta {file}")
            feature_types.append(process_fasta("Antibody Capture", file))

    if par["supplemental_reference"]:
        for file in par["supplemental_reference"]:
            logger.info(f"Processing supp fasta {file}")
            feature_types.append(process_fasta("Other", file))
    
    return pd.concat(feature_types)

def main(par: dict[str, Any], meta: dict[str, Any]):
    # Preprocess params
    par = process_params(par)

    # Create output dir if not exists
    if not os.path.exists(par["output"]):
        os.makedirs(par["output"])

    ## Process parameters
    proc_pars = ["--no-container", "--outdir", par["output"]]

    if par["parallel"]:
        proc_pars.append("--parallel")

    if par["timestamps"]:
        proc_pars.append("--timestamps")

    with tempfile.TemporaryDirectory(prefix="cwl-bd_rhapsody_wta-", dir=meta["temp_dir"]) as temp_dir:
        # extract transcriptome gtf if need be
        if par["transcriptome_annotation"] and is_gz_file(par["transcriptome_annotation"]):
            with open(os.path.join(temp_dir, "transcriptome.gtf"), 'wb') as genes_uncompressed:
                with gzip.open(par["transcriptome_annotation"], 'rb') as genes_compressed:
                    shutil.copyfileobj(genes_compressed, genes_uncompressed)
                    par["transcriptome_annotation"] = genes_uncompressed.name

        # Create params file
        config_file = os.path.join(par["output"], "config.yml")
        config_content = generate_config(par)
        with open(config_file, "w") as f:
            f.write(config_content)

        # Create cwl file (if need be)
        cwl_file = generate_cwl_file(par, meta)

        ## Run pipeline
        if not par["dryrun"]:
            cmd = ["cwl-runner"] + proc_pars + [cwl_file, os.path.basename(config_file)]

            env = dict(os.environ)
            env["TMPDIR"] = temp_dir

            logger.info("> " + ' '.join(cmd))
            _ = subprocess.check_call(
                cmd,
                cwd=os.path.dirname(config_file),
                env=env
            )

        # extracting feature ids from references
        # extract info from reference files (while they still exist)
        feature_df = extract_feature_types(par)
        feature_types_file = os.path.join(par["output"], "feature_types.tsv")
        feature_df.to_csv(feature_types_file, sep="\\t", index=False)


    if not par["dryrun"]:
        # look for counts file
        if not par["sample_prefix"]:
            par["sample_prefix"] = "sample"
        counts_filename = par["sample_prefix"] + "_RSEC_MolsPerCell.csv"
        
        if par["sample_tags_version"]:
            counts_filename = "Combined_" + counts_filename
        counts_file = os.path.join(par["output"], counts_filename)
        
        if not os.path.exists(counts_file):
            raise ValueError(f"Could not find output counts file '{counts_filename}'")

        # look for metrics file
        metrics_filename = par["sample_prefix"] + "_Metrics_Summary.csv"
        metrics_file = os.path.join(par["output"], metrics_filename)
        if not os.path.exists(metrics_file):
            raise ValueError(f"Could not find output metrics file '{metrics_filename}'")

if __name__ == "__main__":
    main(par, meta)
VIASHMAIN
python -B "\$tempscript" &
wait "\$!"

VIASHEOF


# strip viash automount from file paths
if [ ! -z "$VIASH_PAR_INPUT" ]; then
  unset VIASH_TEST_INPUT
  IFS=';'
  for var in $VIASH_PAR_INPUT; do
    unset IFS
    if [ -z "$VIASH_TEST_INPUT" ]; then
      VIASH_TEST_INPUT="$(ViashStripAutomount "$var")"
    else
      VIASH_TEST_INPUT="$VIASH_TEST_INPUT;""$(ViashStripAutomount "$var")"
    fi
  done
  VIASH_PAR_INPUT="$VIASH_TEST_INPUT"
fi
if [ ! -z "$VIASH_PAR_REFERENCE" ]; then
  unset VIASH_TEST_REFERENCE
  IFS=';'
  for var in $VIASH_PAR_REFERENCE; do
    unset IFS
    if [ -z "$VIASH_TEST_REFERENCE" ]; then
      VIASH_TEST_REFERENCE="$(ViashStripAutomount "$var")"
    else
      VIASH_TEST_REFERENCE="$VIASH_TEST_REFERENCE;""$(ViashStripAutomount "$var")"
    fi
  done
  VIASH_PAR_REFERENCE="$VIASH_TEST_REFERENCE"
fi
if [ ! -z "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ]; then
  VIASH_PAR_TRANSCRIPTOME_ANNOTATION=$(ViashStripAutomount "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION")
fi
if [ ! -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
  unset VIASH_TEST_ABSEQ_REFERENCE
  IFS=';'
  for var in $VIASH_PAR_ABSEQ_REFERENCE; do
    unset IFS
    if [ -z "$VIASH_TEST_ABSEQ_REFERENCE" ]; then
      VIASH_TEST_ABSEQ_REFERENCE="$(ViashStripAutomount "$var")"
    else
      VIASH_TEST_ABSEQ_REFERENCE="$VIASH_TEST_ABSEQ_REFERENCE;""$(ViashStripAutomount "$var")"
    fi
  done
  VIASH_PAR_ABSEQ_REFERENCE="$VIASH_TEST_ABSEQ_REFERENCE"
fi
if [ ! -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
  unset VIASH_TEST_SUPPLEMENTAL_REFERENCE
  IFS=';'
  for var in $VIASH_PAR_SUPPLEMENTAL_REFERENCE; do
    unset IFS
    if [ -z "$VIASH_TEST_SUPPLEMENTAL_REFERENCE" ]; then
      VIASH_TEST_SUPPLEMENTAL_REFERENCE="$(ViashStripAutomount "$var")"
    else
      VIASH_TEST_SUPPLEMENTAL_REFERENCE="$VIASH_TEST_SUPPLEMENTAL_REFERENCE;""$(ViashStripAutomount "$var")"
    fi
  done
  VIASH_PAR_SUPPLEMENTAL_REFERENCE="$VIASH_TEST_SUPPLEMENTAL_REFERENCE"
fi
if [ ! -z "$VIASH_PAR_OUTPUT" ]; then
  VIASH_PAR_OUTPUT=$(ViashStripAutomount "$VIASH_PAR_OUTPUT")
fi
if [ ! -z "$VIASH_META_RESOURCES_DIR" ]; then
  VIASH_META_RESOURCES_DIR=$(ViashStripAutomount "$VIASH_META_RESOURCES_DIR")
fi
if [ ! -z "$VIASH_META_EXECUTABLE" ]; then
  VIASH_META_EXECUTABLE=$(ViashStripAutomount "$VIASH_META_EXECUTABLE")
fi
if [ ! -z "$VIASH_META_CONFIG" ]; then
  VIASH_META_CONFIG=$(ViashStripAutomount "$VIASH_META_CONFIG")
fi
if [ ! -z "$VIASH_META_TEMP_DIR" ]; then
  VIASH_META_TEMP_DIR=$(ViashStripAutomount "$VIASH_META_TEMP_DIR")
fi


# check whether required files exist
if [ ! -z "$VIASH_PAR_OUTPUT" ] && [ ! -e "$VIASH_PAR_OUTPUT" ]; then
  ViashError "Output file '$VIASH_PAR_OUTPUT' does not exist."
  exit 1
fi


exit 0
