{
"$schema": "http://json-schema.org/draft-07/schema",
"title": "scvi_knn",
"description": "Cell type annotation workflow that performs scVI integration of reference and query dataset followed by KNN label transfer. \nThe query and reference datasets are expected to be pre-processed in the same way, for example with the `process_samples` workflow of OpenPipeline.\nNote that this workflow will integrate the reference dataset from scratch and integrate the query dataset in the same embedding space. \nThe workflow does not currently output the trained SCVI reference model.\n",
"type": "object",
"definitions": {

    
    "Dataset input": {
        "title": "Dataset input",
        "type": "object",
        "description": "Dataset input using nf-tower \"dataset\" or \"data explorer\". Allows for the input of multiple         parameter sets to initialise a Nextflow channel.",
        "properties": {
            "param_list": {
                "description": "Dataset input can either be a list of maps, a csv file, a json file, a yaml file, or simply a yaml                 blob. The names of the input fields (e.g. csv columns, json keys) need to be an exact match with the workflow input parameters.",
                "default": "",
                "format": "file-path",
                "mimetype": "text/csv",
                "pattern": "^\\S+\\.csv$"
            }
        }
    },

    
    
    "outputs" : {
    "title": "Outputs",
    "type": "object",
    "description": "No description",
    "properties": {
    
        
                "output": {
                "type":
                "string",
                "description": "Type: `file`, required, default: `$id.$key.output.h5mu`, example: `output.h5mu`. The query data in ",
                "help_text": "Type: `file`, required, default: `$id.$key.output.h5mu`, example: `output.h5mu`. The query data in .h5mu format with predicted labels predicted from the classifier trained on the reference."
            ,
                "default":"$id.$key.output.h5mu"
            }
    

        ,
                "output_obs_predictions": {
                "type":
                "string",
                "description": "Type: List of `string`, multiple_sep: `\";\"`. In which `",
                "help_text": "Type: List of `string`, multiple_sep: `\";\"`. In which `.obs` slots to store the predicted cell labels.\nIf provided, must have the same length as `--reference_obs_targets`.\nIf empty, will default to the `reference_obs_targets` combined with the `\"_pred\"` suffix.\n"
            
            }
    

        ,
                "output_obs_probability": {
                "type":
                "string",
                "description": "Type: List of `string`, multiple_sep: `\";\"`. In which `",
                "help_text": "Type: List of `string`, multiple_sep: `\";\"`. In which `.obs` slots to store the probability of the predictions.\nIf provided, must have the same length as `--reference_obs_targets`.\nIf empty, will default to the `reference_obs_targets` combined with the `\"_probability\"` suffix.\n"
            
            }
    

        ,
                "output_obsm_integrated": {
                "type":
                "string",
                "description": "Type: `string`, default: `X_integrated_scvi`. In which ",
                "help_text": "Type: `string`, default: `X_integrated_scvi`. In which .obsm slot to store the integrated embedding."
            ,
                "default":"X_integrated_scvi"
            }
    

}
},
    
    
    "query input" : {
    "title": "Query Input",
    "type": "object",
    "description": "No description",
    "properties": {
    
        
                "id": {
                "type":
                "string",
                "description": "Type: `string`, required, example: `foo`. ID of the sample",
                "help_text": "Type: `string`, required, example: `foo`. ID of the sample."
            
            }
    

        ,
                "input": {
                "type":
                "string",
                "description": "Type: `file`, required, example: `input.h5mu`. Input dataset consisting of the (unlabeled) query observations",
                "help_text": "Type: `file`, required, example: `input.h5mu`. Input dataset consisting of the (unlabeled) query observations."
            
            }
    

        ,
                "modality": {
                "type":
                "string",
                "description": "Type: `string`, default: `rna`. Which modality to process",
                "help_text": "Type: `string`, default: `rna`. Which modality to process. Should match the modality of the --reference dataset."
            ,
                "default":"rna"
            }
    

        ,
                "input_layer": {
                "type":
                "string",
                "description": "Type: `string`, example: `counts`. The layer of the input dataset containing the raw counts if ",
                "help_text": "Type: `string`, example: `counts`. The layer of the input dataset containing the raw counts if .X is not to be used."
            
            }
    

        ,
                "input_layer_lognormalized": {
                "type":
                "string",
                "description": "Type: `string`, example: `log_normalized`. The layer of the input dataset containing the lognormalized counts if ",
                "help_text": "Type: `string`, example: `log_normalized`. The layer of the input dataset containing the lognormalized counts if .X is not to be used."
            
            }
    

        ,
                "input_obs_batch_label": {
                "type":
                "string",
                "description": "Type: `string`, required, example: `sample`. The ",
                "help_text": "Type: `string`, required, example: `sample`. The .obs field in the input (query) dataset containing the batch labels."
            
            }
    

        ,
                "input_var_gene_names": {
                "type":
                "string",
                "description": "Type: `string`. The ",
                "help_text": "Type: `string`. The .var field in the input (query) dataset containing gene names; if not provided, the .var index will be used.\n"
            
            }
    

        ,
                "input_reference_gene_overlap": {
                "type":
                "integer",
                "description": "Type: `integer`, default: `100`. The minimum number of genes present in both the reference and query datasets",
                "help_text": "Type: `integer`, default: `100`. The minimum number of genes present in both the reference and query datasets.\n"
            ,
                "default":100
            }
    

        ,
                "overwrite_existing_key": {
                "type":
                "boolean",
                "description": "Type: `boolean_true`, default: `false`. If provided, will overwrite existing fields in the input dataset when data are copied during the reference alignment process",
                "help_text": "Type: `boolean_true`, default: `false`. If provided, will overwrite existing fields in the input dataset when data are copied during the reference alignment process."
            ,
                "default":false
            }
    

}
},
    
    
    "reference input" : {
    "title": "Reference input",
    "type": "object",
    "description": "No description",
    "properties": {
    
        
                "reference": {
                "type":
                "string",
                "description": "Type: `file`, required, example: `reference.h5mu`. Reference dataset consisting of the labeled observations",
                "help_text": "Type: `file`, required, example: `reference.h5mu`. Reference dataset consisting of the labeled observations."
            
            }
    

        ,
                "reference_layer": {
                "type":
                "string",
                "description": "Type: `string`, example: `counts`. The layer of the reference dataset containing the raw counts if ",
                "help_text": "Type: `string`, example: `counts`. The layer of the reference dataset containing the raw counts if .X is not to be used."
            
            }
    

        ,
                "reference_layer_lognormalized": {
                "type":
                "string",
                "description": "Type: `string`, example: `log_normalized`. The layer of the reference dataset containing the lognormalized counts if ",
                "help_text": "Type: `string`, example: `log_normalized`. The layer of the reference dataset containing the lognormalized counts if .X is not to be used."
            
            }
    

        ,
                "reference_obs_target": {
                "type":
                "string",
                "description": "Type: `string`, required, example: `cell_type`. The `",
                "help_text": "Type: `string`, required, example: `cell_type`. The `.obs` key(s) of the target labels to transfer."
            
            }
    

        ,
                "reference_var_gene_names": {
                "type":
                "string",
                "description": "Type: `string`. The ",
                "help_text": "Type: `string`. The .var field in the reference dataset containing gene names; if not provided, the .var index will be used.\n"
            
            }
    

        ,
                "reference_obs_batch_label": {
                "type":
                "string",
                "description": "Type: `string`, required, example: `sample`. The ",
                "help_text": "Type: `string`, required, example: `sample`. The .obs field in the reference dataset containing the batch labels."
            
            }
    

}
},
    
    
    "hvg subset arguments" : {
    "title": "HVG subset arguments",
    "type": "object",
    "description": "No description",
    "properties": {
    
        
                "n_hvg": {
                "type":
                "integer",
                "description": "Type: `integer`, default: `2000`. Number of highly variable genes to subset for",
                "help_text": "Type: `integer`, default: `2000`. Number of highly variable genes to subset for.\n"
            ,
                "default":2000
            }
    

}
},
    
    
    "scvi integration options" : {
    "title": "scVI integration options",
    "type": "object",
    "description": "No description",
    "properties": {
    
        
                "scvi_early_stopping": {
                "type":
                "boolean",
                "description": "Type: `boolean`. Whether to perform early stopping with respect to the validation set",
                "help_text": "Type: `boolean`. Whether to perform early stopping with respect to the validation set."
            
            }
    

        ,
                "scvi_early_stopping_monitor": {
                "type":
                "string",
                "description": "Type: `string`, default: `elbo_validation`, choices: ``elbo_validation`, `reconstruction_loss_validation`, `kl_local_validation``. Metric logged during validation set epoch",
                "help_text": "Type: `string`, default: `elbo_validation`, choices: ``elbo_validation`, `reconstruction_loss_validation`, `kl_local_validation``. Metric logged during validation set epoch.",
                "enum": ["elbo_validation", "reconstruction_loss_validation", "kl_local_validation"]
            
            ,
                "default":"elbo_validation"
            }
    

        ,
                "scvi_early_stopping_patience": {
                "type":
                "integer",
                "description": "Type: `integer`, default: `45`. Number of validation epochs with no improvement after which training will be stopped",
                "help_text": "Type: `integer`, default: `45`. Number of validation epochs with no improvement after which training will be stopped."
            ,
                "default":45
            }
    

        ,
                "scvi_early_stopping_min_delta": {
                "type":
                "number",
                "description": "Type: `double`, default: `0.0`. Minimum change in the monitored quantity to qualify as an improvement, i",
                "help_text": "Type: `double`, default: `0.0`. Minimum change in the monitored quantity to qualify as an improvement, i.e. an absolute change of less than min_delta, will count as no improvement."
            ,
                "default":0.0
            }
    

        ,
                "scvi_max_epochs": {
                "type":
                "integer",
                "description": "Type: `integer`. Number of passes through the dataset, defaults to (20000 / number of cells) * 400 or 400; whichever is smallest",
                "help_text": "Type: `integer`. Number of passes through the dataset, defaults to (20000 / number of cells) * 400 or 400; whichever is smallest."
            
            }
    

        ,
                "scvi_reduce_lr_on_plateau": {
                "type":
                "boolean",
                "description": "Type: `boolean`, default: `true`. Whether to monitor validation loss and reduce learning rate when validation set `lr_scheduler_metric` plateaus",
                "help_text": "Type: `boolean`, default: `true`. Whether to monitor validation loss and reduce learning rate when validation set `lr_scheduler_metric` plateaus."
            ,
                "default":true
            }
    

        ,
                "scvi_lr_factor": {
                "type":
                "number",
                "description": "Type: `double`, default: `0.6`. Factor to reduce learning rate",
                "help_text": "Type: `double`, default: `0.6`. Factor to reduce learning rate."
            ,
                "default":0.6
            }
    

        ,
                "scvi_lr_patience": {
                "type":
                "number",
                "description": "Type: `double`, default: `30.0`. Number of epochs with no improvement after which learning rate will be reduced",
                "help_text": "Type: `double`, default: `30.0`. Number of epochs with no improvement after which learning rate will be reduced."
            ,
                "default":30.0
            }
    

}
},
    
    
    "leiden clustering options" : {
    "title": "Leiden clustering options",
    "type": "object",
    "description": "No description",
    "properties": {
    
        
                "leiden_resolution": {
                "type":
                "string",
                "description": "Type: List of `double`, default: `1.0`, multiple_sep: `\";\"`. Control the coarseness of the clustering",
                "help_text": "Type: List of `double`, default: `1.0`, multiple_sep: `\";\"`. Control the coarseness of the clustering. Higher values lead to more clusters."
            ,
                "default":"1.0"
            }
    

}
},
    
    
    "neighbor classifier arguments" : {
    "title": "Neighbor classifier arguments",
    "type": "object",
    "description": "No description",
    "properties": {
    
        
                "knn_weights": {
                "type":
                "string",
                "description": "Type: `string`, default: `uniform`, choices: ``uniform`, `distance``. Weight function used in prediction",
                "help_text": "Type: `string`, default: `uniform`, choices: ``uniform`, `distance``. Weight function used in prediction. Possible values are:\n`uniform` (all points in each neighborhood are weighted equally) or \n`distance` (weight points by the inverse of their distance)\n",
                "enum": ["uniform", "distance"]
            
            ,
                "default":"uniform"
            }
    

        ,
                "knn_n_neighbors": {
                "type":
                "integer",
                "description": "Type: `integer`, default: `15`. The number of neighbors to use in k-neighbor graph structure used for fast approximate nearest neighbor search with PyNNDescent",
                "help_text": "Type: `integer`, default: `15`. The number of neighbors to use in k-neighbor graph structure used for fast approximate nearest neighbor search with PyNNDescent. \nLarger values will result in more accurate search results at the cost of computation time.\n"
            ,
                "default":15
            }
    

}
},
    
    
    "nextflow input-output arguments" : {
    "title": "Nextflow input-output arguments",
    "type": "object",
    "description": "Input/output parameters for Nextflow itself. Please note that both publishDir and publish_dir are supported but at least one has to be configured.",
    "properties": {
    
        
                "publish_dir": {
                "type":
                "string",
                "description": "Type: `string`, required, example: `output/`. Path to an output directory",
                "help_text": "Type: `string`, required, example: `output/`. Path to an output directory."
            
            }
    

        

}
}
},
"allOf": [

    {
    "$ref": "#/definitions/outputs"
    },

    {
    "$ref": "#/definitions/query input"
    },

    {
    "$ref": "#/definitions/reference input"
    },

    {
    "$ref": "#/definitions/hvg subset arguments"
    },

    {
    "$ref": "#/definitions/scvi integration options"
    },

    {
    "$ref": "#/definitions/leiden clustering options"
    },

    {
    "$ref": "#/definitions/neighbor classifier arguments"
    },

    {
    "$ref": "#/definitions/nextflow input-output arguments"
    }
]
}
