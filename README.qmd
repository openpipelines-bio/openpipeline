---
title: openpipeline
format: gfm
---

<!-- README.md is generated by running 'quarto render README.qmd' -->

```{r, echo = FALSE, message = FALSE, error = FALSE, warning = FALSE}
library(tidyverse)
```

Extensible single cell analysis pipelines for reproducible and large-scale single cell processing using Viash and Nextflow. 

The provided pipelines are built using the [Viash framework](http://www.viash.io) on top of the 
nextflow workflow system. For more information on Nextflow please visit the [Nextflow github page](https://github.com/nextflow-io/nextflow) 
and the [Nextflow read the docs page](https://www.nextflow.io/docs/latest/index.html).

### Getting started

Run `bin/init`.

### List of components

The results below were generated by running `bin/viash_build; bin/viash_test`.

```{r readyaml, echo = FALSE, warning = FALSE, error = FALSE, message = FALSE, results='asis'}
# get viash to generate a yaml of all components
out <- processx::run(
  command = "bin/viash", args = c("ns", "list", "-p", "docker"),
)
comp_yamls <- yaml::read_yaml(text = out$stdout)
```

```{r yamlasdf, echo = FALSE, warning = FALSE, error = FALSE, message = FALSE, results='asis'}
# format relevant information as a data frame
comp_df <- map_df(seq_along(comp_yamls), function(i) {
  ya <- comp_yamls[[i]]
  auths <- ya$functionality$authors
  maintainer <- auths[map_lgl(auths, function(aut) "maintainer" %in% aut$roles)] %>% 
    first()
  
  tibble(
    conf = ya$info$config,
    name = ya$functionality$name,
    namespace = ya$functionality$namespace %||% NA_character_,
    maintainer_name = maintainer$name %||% NA_character_,
    maintainer_email = maintainer$email %||% NA_character_,
    maintainer_account = maintainer$props$github %||% NA_character_,
    platform = ya$platform$type %||% NA_character_
  )
})
```

```{r readtsv, echo = FALSE, warning = FALSE, error = FALSE, message = FALSE, results='asis'}
# read `project_test` results
test_results <- 
  read_tsv(".viash_log_test.tsv") %>% 
  group_by(namespace, name = functionality, platform) %>% 
  summarise(
    setup_succeeded = any(test_name == "build_executable" & exit_code == 0),
    num_tests = sum(exit_code[test_name != "build_executable"] >= 0),
    num_succeeds = sum(exit_code[test_name != "build_executable"] == 0),
    status_label = case_when(
      !setup_succeeded ~ "SETUP FAIL!",
      num_tests == 0 ~ "no tests",
      TRUE ~ paste0(num_succeeds, " out of ", num_tests)
    ),
    status_colour = case_when(
      !setup_succeeded ~ "red",
      num_tests == 0 ~ "orange", 
      num_tests != num_succeeds ~ "red",
      TRUE ~ "brightgreen"
    ),
    duration = sum(duration),
    .groups = "drop"
  )

# provide defaults for tests which did not finish (DNF)
fail_defaults <- tibble(
  setup_succeeded = FALSE,
  num_tests = 0L,
  num_succeeds = 0L,
  status_label = "DNF",
  status_colour = "red",
  duration = NA
)

dnf_fill <- comp_df %>% 
  select(namespace, name, platform) %>% 
  anti_join(test_results, by = c("namespace", "name", "platform")) %>% 
  crossing(fail_defaults)
```

```{r mdtable, echo = FALSE, warning = FALSE, error = FALSE, message = FALSE, results='asis'}
# combine info final markdown table
bind_rows(
  test_results,
  dnf_fill
) %>% 
  left_join(comp_df, by = c("namespace", "name", "platform")) %>% 
  arrange(namespace, name, platform) %>% 
  transmute(
    Namespace = namespace,
    Component = glue::glue("[{name}]({conf})"),
    Tests = paste0("![tests](https://img.shields.io/badge/tests-", status_label, "-", status_colour, ")"),
    Maintainer = ifelse(!is.na(maintainer_account), glue::glue("[{maintainer_account}](https://github.com/{maintainer_account})"), ifelse(!is.na(maintainer_name), maintainer_name, "")),
    `Duration (s)` = duration
  ) %>% 
  knitr::kable()
```
